{"version":3,"file":"index.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAmBA,mGAA8C;AAG9C,SAAe,IAAI;;QAEf,IAAI,MAAM,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC;QAC3D,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAEpC,wCAAwC;QACxC,qCAAqC;QACrC,iCAAiC;QACjC,iCAAiC;QACjC,mCAAmC;QACnC,kCAAkC;QAClC,mCAAmC;QACnC,oCAAoC;QACpC,wCAAwC;QACxC,+BAA+B;QAC/B,mCAAmC;QACnC,oCAAoC;QACpC,kCAAkC;QAClC,gCAAgC;QAChC,iCAAiC;QACjC,gCAAgC;QAChC,iCAAiC;QACjC,sCAAsC;QACtC,4CAA4C;QAC5C,IAAI,KAAK,GAAG,MAAM,yBAAO,GAAE,CAAC;QAE5B,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IAE9B,CAAC;CAAA;AAED,IAAI,EAAE,CAAC;;;;;;;;;;;;;;ACpDP,MAAM,EAAE,GAAG;;;;;;;;CAQV,CAAC;AAEF,MAAM,EAAE,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsIV,CAAC;AAEF,SAAgB,OAAO;IAEnB,IAAI,KAAK,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACtC,IAAI,cAAc,GAAG,IAAI,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAClD,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,GAAG,cAAc,CAAC;IAE3C,KAAK;IACL,IAAI,QAAQ,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;IAClD,IAAI,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAc,IAAI,CAAC,MAAM,CAAC,CAAC;IAC7D,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAEzB,gBAAgB;IAChB,IAAI,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CACvC,eAAe,EACf,IAAI,GAAG,CAAS,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,EACrF,IAAI,GAAG,CAAS,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,YAAY,EAAE,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CACzF,CAAC;IACF,MAAM,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IAEvB,QAAQ;IACR,MAAM,CAAC,aAAa,GAAG,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,IAAI,WAAW,EAAE,CAAC,CAAC,CAAC;IAE3E,OAAO,KAAK,CAAC;AACjB,CAAC;AAvBD,0BAuBC;AAED;;;;GAIG;AACH,MAAM,WAAY,SAAQ,IAAI,CAAC,UAAU;IAE3B,WAAW;QAEjB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC;IAEpE,CAAC;CAEJ;;;;;;;UCxLD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://limit/./src/index.ts","webpack://limit/./src/scenes/20_Driving.ts","webpack://limit/webpack/bootstrap","webpack://limit/webpack/before-startup","webpack://limit/webpack/startup","webpack://limit/webpack/after-startup"],"sourcesContent":["import { ProceduralSkybox } from \"./scenes/01_ProceduralSkybox\";\r\nimport { CubeMapSkybox } from \"./scenes/02_CubeMapSkybox\";\r\nimport { Component } from \"./scenes/03_Component\";\r\nimport { Geometrys } from \"./scenes/04_Geometrys\";\r\nimport { UVGeometrys } from \"./scenes/05_UVGeometrys\";\r\nimport { CustomMesh } from \"./scenes/06_CustomMesh\";\r\nimport { DataTexture } from \"./scenes/07_DataTexture\";\r\nimport { RenderTarget } from \"./scenes/08_RenderTarget\";\r\nimport { CubeRenderTarget } from \"./scenes/09_CubeRenderTarget\";\r\nimport { LoadHDR } from \"./scenes/10_LoadHDR\";\r\nimport { PBRMaterial } from \"./scenes/11_PBRMaterial\";\r\nimport { PBRGeometrys } from \"./scenes/12_PBRGeometrys\";\r\nimport { PBRTexture } from \"./scenes/13_PBRTexture\";\r\nimport { LoadGLTF } from \"./scenes/14_LoadGLTF\";\r\nimport { LoadGLTF2 } from \"./scenes/15_LoadGLTF2\";\r\nimport { BlurPass } from \"./scenes/16_BlurPass\";\r\nimport { BloomPass } from \"./scenes/17_BloomPass\";\r\nimport { CustomMaterial } from \"./scenes/18_CustomMaterial\";\r\nimport { CustomPostprocessing } from \"./scenes/19_CustomPostprocessing\";\r\nimport { Driving } from \"./scenes/20_Driving\";\r\n\r\n\r\nasync function main() {\r\n\r\n    let engine = new Apex.Engine({ width: 1200, height: 800 });\r\n    document.body.append(engine.output);\r\n\r\n    // let scene = await ProceduralSkybox();\r\n    // let scene = await CubeMapSkybox();\r\n    // let scene = await Component();\r\n    // let scene = await Geometrys();\r\n    // let scene = await UVGeometrys();\r\n    // let scene = await CustomMesh();\r\n    // let scene = await DataTexture();\r\n    // let scene = await RenderTarget();\r\n    // let scene = await CubeRenderTarget();\r\n    // let scene = await LoadHDR();\r\n    // let scene = await PBRMaterial();\r\n    // let scene = await PBRGeometrys();\r\n    // let scene = await PBRTexture();\r\n    // let scene = await LoadGLTF();\r\n    // let scene = await LoadGLTF2();\r\n    // let scene = await BlurPass();\r\n    // let scene = await BloomPass();\r\n    // let scene = await CustomMaterial();\r\n    // let scene = await CustomPostprocessing();\r\n    let scene = await Driving();\r\n\r\n    engine.launchScene(scene);\r\n\r\n}\r\n\r\nmain();","const vs = `\r\n    in vec3 a_Position;\r\n    in vec2 a_Uv;\r\n    out vec2 v_Uv;\r\n    void main(){\r\n        gl_Position = vec4(a_Position, 1.0);\r\n        v_Uv = a_Uv;\r\n    }\r\n`;\r\n\r\nconst fs = `\r\n    in vec2 v_Uv;\r\n    uniform vec2 u_ScreenSize;\r\n    uniform float u_Time;\r\n    out vec4 fragColor;\r\n\r\n    const vec3 skyColor = vec3(200.0 / 255.0 * 1.6, 100.0 / 255.0 * 1.6, 0.0 / 255.0 * 1.6);\r\n    const vec3 groundColor = vec3(0.0);\r\n    const vec3 fog = vec3(1.0, 0.0, 0.0);\r\n    const vec3 sunColor = vec3(1.0, 0.9, 0.0);\r\n    const vec3 sunPosAndRadius = vec3(1.0, 0.6, 0.18);\r\n    const vec4 haloAndThickness = vec4(1.0, 0.93, 0.0, 0.2);\r\n    const vec3 buildColor = vec3(0.3, 0.3, 0.3);\r\n\r\n    const float PI2 = 6.2831852;\r\n\r\n    float hash11(float p)\r\n    {\r\n        p = fract(p * 0.1031);\r\n        p *= p + 33.33;\r\n        p *= p + p;\r\n        return fract(p);\r\n    }\r\n\r\n    float easeQuadraticOut(float t) {\r\n        return t * (2.0 - t);\r\n    }\r\n\r\n    float easeExpoOut(float t) {\r\n        return (t == 1.0) ? 1.0 : (-pow(2.0, -10.0 * t) + 1.0);\r\n    }\r\n\r\n    float section(float l, float r, float v) {\r\n        return step(l, v) * step(v, r);\r\n    }\r\n\r\n    void grid(in vec2 norUv, in float speed, out vec3 bg) {\r\n        vec2 q = 10.0 * vec2(norUv.x / (norUv.y + 1.0), 2.0 / (norUv.y + 1.0));\r\n        vec2 qh = vec2(q.x, round(q.y));\r\n        vec2 qv = vec2(round(q.x - speed * u_Time) + speed * u_Time, q.y);\r\n        float dq = min(length(q - qh), length(q - qv));\r\n        float intensity = 0.2;\r\n        bg += 0.5 * skyColor * smoothstep(0.1, 0.0, dq) * smoothstep(-0.9, 0.5, norUv.y) * intensity;\r\n    }\r\n\r\n    void sun(in float d, out vec3 bg) {\r\n        float s = step(sunPosAndRadius.z, d);\r\n        bg = s * bg + (1. - s) * sunColor;\r\n    }\r\n\r\n    void halo(in float d, out vec3 bg) {\r\n        float t = clamp(abs(d - sunPosAndRadius.z) / haloAndThickness.w, 0.0, 1.0);\r\n        t = easeExpoOut(t);\r\n        bg = mix(haloAndThickness.rgb, bg, t);\r\n    }\r\n\r\n    void building(in vec2 uv, in vec4 ssom, in float intensity, out vec3 bg) {\r\n        float scale = ssom.x;\r\n        float speed = ssom.y;\r\n        float offset = ssom.z;\r\n        float maxH = ssom.w;\r\n        float x = floor(uv.x * scale + u_Time * speed + offset);\r\n        float h = hash11(x) * maxH;\r\n        bg = step(h, uv.y) * bg + step(uv.y, h) * buildColor * intensity;\r\n    }\r\n\r\n    void plane(in vec2 uv, out vec3 bg) {\r\n\r\n        float f = 1.0;\r\n        //顶部\r\n        f = section(0.2, 0.25, uv.x) * step(uv.y, 0.26);\r\n        f = max(f, section(0.25, 0.3, uv.x) * step(uv.y, 0.13 + (-2.6 * (uv.x - 0.3))));\r\n        f = max(f, section(0.3, 0.62, uv.x) * step(uv.y, 0.13 + smoothstep(0.3, 0.62, uv.x) * 0.08));\r\n        f = max(f, section(0.62, 0.85, uv.x) * step(uv.y, smoothstep(0.95, 0.62, uv.x) * 0.21));\r\n\r\n        //尾部\r\n        f *= max(1.0 - section(0.12, 0.26, uv.y), step(0.2 + (-0.15 * (uv.y - 0.26)), uv.x));\r\n        f *= max(1.0 - section(0.10, 0.12, uv.y), step(0.221 + (1.5 * (uv.y - 0.12)), uv.x));\r\n        f *= max(1.0 - section(0.03, 0.05, uv.y), step(0.221 + (-1.5 * (uv.y - 0.03)), uv.x));\r\n\r\n        //底部\r\n        f *= max(1.0 - section(0.2, 0.85, uv.x), step(0.03 + smoothstep(0.5, 0.75, uv.x) * 0.025, uv.y));\r\n        bg = mix(bg, vec3(0.0), f);\r\n\r\n        //流线\r\n        float x = clamp(uv.x, 0.225, 0.835);\r\n        float y = 0.03 + smoothstep(0.4, 0.85, x) * 0.025;\r\n        float d = length(uv - vec2(x, y));\r\n        float intensity = pow(0.05 + 0.6 * sin(PI2 * x + 0.003 * u_Time), 5.0) + 0.02;\r\n        bg += vec3(1.0 , 0.1, 0.0) * 0.0001 / (d * d + 0.00001) * smoothstep(-1.0, 1.0, x) * intensity;\r\n        \r\n    }\r\n\r\n    void pole(in vec2 uv, in vec2 sr, out vec3 bg) {\r\n        float speed = sr.x;\r\n        float radius = sr.y;\r\n        float pos = mod(2.0 + u_Time * speed, 2.0);\r\n        float d = abs(uv.x - pos);\r\n        bg = mix(bg, vec3(0.0), smoothstep(radius, 0.0, d));\r\n    }\r\n\r\n    void main(){\r\n\r\n        vec2 uv = v_Uv;\r\n        //将(0, 0)移至中心、uv等距化\r\n        vec2 norUv = (2.0 * gl_FragCoord.xy - u_ScreenSize) / min(u_ScreenSize.x, u_ScreenSize.y);\r\n\r\n        //背景\r\n        vec3 bg = skyColor;\r\n\r\n        //网格\r\n        grid(norUv, -0.0005, bg);\r\n\r\n        //太阳\r\n        float d = length(norUv - sunPosAndRadius.xy);\r\n        sun(d, bg);\r\n        halo(d, bg);\r\n\r\n        //建筑\r\n        building(uv, vec4(40.0, 0.001, 0.0, 0.4), 1.0, bg);\r\n        building(uv, vec4(20.0, 0.002, 1000.0, 0.6), 0.5, bg);\r\n\r\n        //雾\r\n        bg = mix(fog, bg, easeQuadraticOut(uv.y));\r\n        bg = mix(groundColor, bg, easeQuadraticOut(uv.y));\r\n\r\n        //战机\r\n        plane(uv, bg);\r\n\r\n        //柱子\r\n        pole(uv, vec2(-0.005, 0.05), bg);\r\n        fragColor = vec4(bg, 1.0);\r\n\r\n    }\r\n`;\r\n\r\nexport function Driving(): Apex.Scene {\r\n\r\n    let scene = new Apex.Scene(\"Driving\");\r\n    let skyboxMaterial = new Apex.SkySphereMaterial();\r\n    scene.env.skybox.material = skyboxMaterial;\r\n\r\n    //摄像机\r\n    let cameraGo = new Apex.GameObject(\"Main Camera\");\r\n    let camera = cameraGo.addComponent<Apex.Camera>(Apex.Camera);\r\n    scene.addChild(cameraGo);\r\n\r\n    //创建InvertShader\r\n    let shader = Apex.Managers.Shader.addShader(\r\n        \"DrivingShader\",\r\n        new Set<string>([Apex.Const.ATTRIBUTE_MAP.a_Position, Apex.Const.ATTRIBUTE_MAP.a_Uv]),\r\n        new Set<string>([Apex.Const.UNIFORM_MAP.u_ScreenSize, Apex.Const.UBO_ITEM_MAP.u_Time])\r\n    );\r\n    shader.addPass(vs, fs);\r\n\r\n    //在后期上作画\r\n    camera.postprocessor = new Apex.Postprocessor(camera, [new DrivingPass()]);\r\n\r\n    return scene;\r\n}\r\n\r\n/**\r\n *@author jhui\r\n *@description Synthwave song\r\n *@date 2023-04-11 19:13:18\r\n */\r\nclass DrivingPass extends Apex.EffectPass {\r\n\r\n    protected _initShader(): void {\r\n\r\n        this._shader = Apex.Managers.Shader.findShader(\"DrivingShader\");\r\n\r\n    }\r\n\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"sourceRoot":""}